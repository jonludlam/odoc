Module substitution

This test substitutes one module for another. We substitute
SubTargets in place of SubstituteMe, so the result expected is that
the equations for t, u and v point to SubTargets rather than SubstituteMe

BEFORE
======
S: sig
type tt/33 = resolved(local(SubstituteMe/24)).t
type uu/34 = resolved(local(SubstituteMe/24)).u
type vv/35 = resolved(local(SubstituteMe/24)).v
 (removed=[])end

AFTER 
======
S: sig
type tt/36 DelayedSubst (<subst>, = resolved(local(SubstituteMe/24)).t)
type uu/37 DelayedSubst (<subst>, = resolved(local(SubstituteMe/24)).u)
type vv/38 DelayedSubst (<subst>, = resolved(local(SubstituteMe/24)).v)
 (removed=[])end

Test AB CD
	local(A/0) -> local(B/0)
	local(B/0) -> local(B/0)
	local(C/0) -> local(D/0)
	local(D/0) -> local(D/0)
Test BC AB
	local(A/0) -> local(B/0)
	local(B/0) -> local(C/0)
	local(C/0) -> local(C/0)
Test AB BC
	local(A/0) -> local(C/0)
	local(B/0) -> local(C/0)
	local(C/0) -> local(C/0)
Test AB CD BC
	local(A/0) -> local(C/0)
	local(B/0) -> local(C/0)
	local(C/0) -> local(D/0)
	local(D/0) -> local(D/0)
Test AB CD AC
	local(A/0) -> local(B/0)
	local(B/0) -> local(B/0)
	local(C/0) -> local(D/0)
	local(D/0) -> local(D/0)
Test ABCD DEFC BF
	local(A/0) -> local(F/0)
	local(B/0) -> local(F/0)
	local(C/0) -> local(E/0)
	local(D/0) -> local(E/0)
	local(E/0) -> local(E/0)
	local(F/0) -> local(C/0)
Test (a/0 -> (resolved(b/0) * resolved(c/0))) (c/0 -> resolved(d/0))
	resolved(a/0) -> (resolved(b/0) * resolved(d/0))
