Basic resolution 1
Simplest possible resolution
CODE
====

type t
type u = t
    
BEFORE
======
type (root Root).t
type (root Root).u = resolved[global((root Root).t)]

AFTER 
===== 
type (root Root).t
type (root Root).u = resolved[global((root Root).t)]

Basic resolution 2
Environment lookup
CODE
====

module M : sig
    type t
end
type u = M.t
    
BEFORE
======
module (root Root).M : sig
  type (root Root).M.t
  end
type (root Root).u = resolved[global((root Root).M)].t

AFTER 
===== 
module (root Root).M : sig
  type (root Root).M.t
  end
type (root Root).u = resolved[global((root Root).M).t]

Basic resolution 3
Module type
CODE
====

module type M = sig
    type t
end
module N : M
type u = N.t
    
BEFORE
======
module type (root Root).M = sig
  type (root Root).M.t
  end
module (root Root).N : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).N)].t

AFTER 
===== 
module type (root Root).M = sig
  type (root Root).M.t
  end
module (root Root).N : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).N).t]

Basic resolution 4
Module type
CODE
====

module type M = sig
    module N : sig
        type t
    end
end
module A : M
type u = A.N.t
    
BEFORE
======
module type (root Root).M = sig
  module (root Root).M.N : sig
    type (root Root).M.N.t
    end
  end
module (root Root).A : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).A)].N.t

AFTER 
===== 
module type (root Root).M = sig
  module (root Root).M.N : sig
    type (root Root).M.N.t
    end
  end
module (root Root).A : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).A).N.t]

Basic resolution 4
Module type
CODE
====

module type M = sig
    module type N = sig
        type t
    end
    module B : N
end
module A : M
type u = A.B.t
    
BEFORE
======
module type (root Root).M = sig
  module type (root Root).M.N = sig
    type (root Root).M.N.t
    end
  module (root Root).M.B : resolved[global((root Root).M.N)]
  end
module (root Root).A : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).A)].B.t

AFTER 
===== 
module type (root Root).M = sig
  module type (root Root).M.N = sig
    type (root Root).M.N.t
    end
  module (root Root).M.B : resolved[global((root Root).M.N)]
  end
module (root Root).A : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).A)].B.t

Basic resolution 4
Module type
CODE
====

module type M = sig
    module type N = sig
        type t
    end
    module X : sig
        module B : N
    end
end
module A : M
type u = A.X.B.t
    
BEFORE
======
module type (root Root).M = sig
  module type (root Root).M.N = sig
    type (root Root).M.N.t
    end
  module (root Root).M.X : sig
    module (root Root).M.X.B : resolved[global((root Root).M.N)]
    end
  end
module (root Root).A : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).A)].X.B.t

AFTER 
===== 
module type (root Root).M = sig
  module type (root Root).M.N = sig
    type (root Root).M.N.t
    end
  module (root Root).M.X : sig
    module (root Root).M.X.B : resolved[global((root Root).M.N)]
    end
  end
module (root Root).A : resolved[global((root Root).M)]
type (root Root).u = resolved[global((root Root).A)].X.B.t

Module substitution
Ensure a substitution is taken into account during resolution
CODE
====

module type A = sig
module M : sig module type S end
module N : M.S
end

module B : sig module type S = sig type t end end

module C : A with module M = B

type t = C.N.t
    
BEFORE
======
module type (root Root).A = sig
  module (root Root).A.M : sig
    module type (root Root).A.M.S
    end
  module (root Root).A.N : resolved[global((root Root).A.M)].S
  end
module (root Root).B : sig
  module type (root Root).B.S = sig
    type (root Root).B.S.t
    end
  end
module (root Root).C : resolved[global((root Root).A)] with [*.M = = resolved[global((root Root).B)]]
type (root Root).t = resolved[global((root Root).C)].N.t

AFTER 
===== 
module type (root Root).A = sig
  module (root Root).A.M : sig
    module type (root Root).A.M.S
    end
  module (root Root).A.N : resolved[global((root Root).A.M).S]
  end
module (root Root).B : sig
  module type (root Root).B.S = sig
    type (root Root).B.S.t
    end
  end
module (root Root).C : resolved[global((root Root).A)] with [root_module_type(global((root Root).A)).M = = resolved[global((root Root).B)]]
type (root Root).t = resolved[(unimplemented resolved_path.S subst-> global((root Root).C).N).t]

Module substitution2
Ensure a destructive substitution is taken into account during resolution
CODE
====

module type A = sig
module M : sig module type S end
module N : M.S
end

module B : sig module type S = sig type t end end

module C : A with module M := B

type t = C.N.t
    
BEFORE
======
module type (root Root).A = sig
  module (root Root).A.M : sig
    module type (root Root).A.M.S
    end
  module (root Root).A.N : resolved[global((root Root).A.M)].S
  end
module (root Root).B : sig
  module type (root Root).B.S = sig
    type (root Root).B.S.t
    end
  end
module (root Root).C : resolved[global((root Root).A)] with [*.M := resolved[global((root Root).B)]]
type (root Root).t = resolved[global((root Root).C)].N.t

AFTER 
===== 
module type (root Root).A = sig
  module (root Root).A.M : sig
    module type (root Root).A.M.S
    end
  module (root Root).A.N : resolved[global((root Root).A.M).S]
  end
module (root Root).B : sig
  module type (root Root).B.S = sig
    type (root Root).B.S.t
    end
  end
module (root Root).C : resolved[global((root Root).A)] with [root_module_type(global((root Root).A)).M := resolved[global((root Root).B)]]
type (root Root).t = resolved[(unimplemented resolved_path.S subst-> global((root Root).C).N).t]

Module alias
Resolve a module alias
CODE
====

module A : sig
    type t
end
module B = A
type t = B.t

BEFORE
======
module (root Root).A : sig
  type (root Root).A.t
  end
module (root Root).B = resolved[global((root Root).A)]
type (root Root).t = resolved[global((root Root).B)].t

AFTER 
===== 
module (root Root).A : sig
  type (root Root).A.t
  end
module (root Root).B = resolved[global((root Root).A)]
type (root Root).t = resolved[(global((root Root).A) -> global((root Root).B)).t]

Module alias
Resolve a module alias
CODE
====

module A : sig
    type t
end
module B = A
module C = B
type t = C.t

BEFORE
======
module (root Root).A : sig
  type (root Root).A.t
  end
module (root Root).B = resolved[global((root Root).A)]
module (root Root).C = resolved[global((root Root).B)]
type (root Root).t = resolved[global((root Root).C)].t

AFTER 
===== 
module (root Root).A : sig
  type (root Root).A.t
  end
module (root Root).B = resolved[global((root Root).A)]
module (root Root).C = resolved[(global((root Root).A) -> global((root Root).B))]
type (root Root).t = resolved[((global((root Root).A) -> global((root Root).B)) -> global((root Root).C)).t]

Functor
Resolve a functor
CODE
====

module type S = sig
  type t
end

module F ( X : S ) ( Y : S ) : sig
  type x_t = X.t
  type y_t = Y.t
  type f_t = x_t
end

BEFORE
======
module type (root Root).S = sig
  type (root Root).S.t
  end
module (root Root).F : ((param (root Root).F X) : resolved[global((root Root).S)]) -> ((param (root Root).F.result Y) : resolved[global((root Root).S)]) -> sig
  type (root Root).F.result.result.x_t = resolved[global((param (root Root).F X))].t
  type (root Root).F.result.result.y_t = resolved[global((param (root Root).F.result Y))].t
  type (root Root).F.result.result.f_t = resolved[global((root Root).F.result.result.x_t)]
  end

AFTER 
===== 
module type (root Root).S = sig
  type (root Root).S.t
  end
module (root Root).F : ((param (root Root).F X) : resolved[global((root Root).S)]) -> ((param (root Root).F.result Y) : resolved[global((root Root).S)]) -> sig
  type (root Root).F.result.result.x_t = resolved[global((param (root Root).F X)).t]
  type (root Root).F.result.result.y_t = resolved[global((param (root Root).F.result Y)).t]
  type (root Root).F.result.result.f_t = resolved[global((root Root).F.result.result.x_t)]
  end

Functor
Resolve a functor
CODE
====

module type S =
sig
  type t
end

module type S1 = functor (_ : S) -> S

module F1 : functor (Arg : S) -> S

module F2 : functor (Arg : S) -> (S with type t = Arg.t)

module F3 : functor (Arg : S) ->
sig
  type t = Arg.t
end

module F4 (Arg : S) : S

module F5 (Arg1 : S) (Arg2 : S) (Arg3 : S) : sig
        type t = Arg1.t
        type u = Arg2.t
        type v = Arg3.t
        type z = t
end

module F6 : S1

module type F7 = functor (Arg : S) -> sig
  type t = Arg.t
  type u = t
end
BEFORE
======
module type (root Root).S = sig
  type (root Root).S.t
  end
module type (root Root).S1 = ((param (root Root).S1 _) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)]
module (root Root).F1 : ((param (root Root).F1 Arg) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)]
module (root Root).F2 : ((param (root Root).F2 Arg) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)] with [*.t = resolved[global((param (root Root).F2 Arg))].t]
module (root Root).F3 : ((param (root Root).F3 Arg) : resolved[global((root Root).S)]) -> sig
  type (root Root).F3.result.t = resolved[global((param (root Root).F3 Arg))].t
  end
module (root Root).F4 : ((param (root Root).F4 Arg) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)]
module (root Root).F5 : ((param (root Root).F5 Arg1) : resolved[global((root Root).S)]) -> ((param (root Root).F5.result Arg2) : resolved[global((root Root).S)]) -> ((param (root Root).F5.result.result Arg3) : resolved[global((root Root).S)]) -> sig
  type (root Root).F5.result.result.result.t = resolved[global((param (root Root).F5 Arg1))].t
  type (root Root).F5.result.result.result.u = resolved[global((param (root Root).F5.result Arg2))].t
  type (root Root).F5.result.result.result.v = resolved[global((param (root Root).F5.result.result Arg3))].t
  type (root Root).F5.result.result.result.z = resolved[global((root Root).F5.result.result.result.t)]
  end
module (root Root).F6 : resolved[global((root Root).S1)]
module type (root Root).F7 = ((param (root Root).F7 Arg) : resolved[global((root Root).S)]) -> sig
  type (root Root).F7.result.t = resolved[global((param (root Root).F7 Arg))].t
  type (root Root).F7.result.u = resolved[global((root Root).F7.result.t)]
  end

AFTER 
===== 
module type (root Root).S = sig
  type (root Root).S.t
  end
module type (root Root).S1 = ((param (root Root).S1 _) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)]
module (root Root).F1 : ((param (root Root).F1 Arg) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)]
module (root Root).F2 : ((param (root Root).F2 Arg) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)] with [root_module_type(global((root Root).S)).t = resolved[global((param (root Root).F2 Arg)).t]]
module (root Root).F3 : ((param (root Root).F3 Arg) : resolved[global((root Root).S)]) -> sig
  type (root Root).F3.result.t = resolved[global((param (root Root).F3 Arg)).t]
  end
module (root Root).F4 : ((param (root Root).F4 Arg) : resolved[global((root Root).S)]) -> resolved[global((root Root).S)]
module (root Root).F5 : ((param (root Root).F5 Arg1) : resolved[global((root Root).S)]) -> ((param (root Root).F5.result Arg2) : resolved[global((root Root).S)]) -> ((param (root Root).F5.result.result Arg3) : resolved[global((root Root).S)]) -> sig
  type (root Root).F5.result.result.result.t = resolved[global((param (root Root).F5 Arg1)).t]
  type (root Root).F5.result.result.result.u = resolved[global((param (root Root).F5.result Arg2)).t]
  type (root Root).F5.result.result.result.v = resolved[global((param (root Root).F5.result.result Arg3)).t]
  type (root Root).F5.result.result.result.z = resolved[global((root Root).F5.result.result.result.t)]
  end
module (root Root).F6 : resolved[global((root Root).S1)]
module type (root Root).F7 = ((param (root Root).F7 Arg) : resolved[global((root Root).S)]) -> sig
  type (root Root).F7.result.t = resolved[global((param (root Root).F7 Arg)).t]
  type (root Root).F7.result.u = resolved[global((root Root).F7.result.t)]
  end

Functor
Resolve a functor
CODE
====

module type ARG = sig
  module type S
end

module F : functor (X : ARG) -> sig
  module N : X.S 
end

module M : sig
  module type S = sig
    type t
  end
end

type t = F(M).N.t

BEFORE
======
module type (root Root).ARG = sig
  module type (root Root).ARG.S
  end
module (root Root).F : ((param (root Root).F X) : resolved[global((root Root).ARG)]) -> sig
  module (root Root).F.result.N : resolved[global((param (root Root).F X))].S
  end
module (root Root).M : sig
  module type (root Root).M.S = sig
    type (root Root).M.S.t
    end
  end
type (root Root).t = resolved[global((root Root).F)](resolved[global((root Root).M)]).N.t

AFTER 
===== 
module type (root Root).ARG = sig
  module type (root Root).ARG.S
  end
module (root Root).F : ((param (root Root).F X) : resolved[global((root Root).ARG)]) -> sig
  module (root Root).F.result.N : resolved[global((param (root Root).F X)).S]
  end
module (root Root).M : sig
  module type (root Root).M.S = sig
    type (root Root).M.S.t
    end
  end
type (root Root).t = resolved[(global((root Root).M).S subst-> global((root Root).F)(resolved[global((root Root).M)]).N).t]

Functor app nightmare
Horrible
CODE
====

module type Type = sig module type T end
module App : functor (T : Type) (F : Type -> Type) (M : F(T).T) -> F(T).T
module Bar : sig module type T = sig type bar end end
module Foo :
  functor (T : Type) -> sig module type T = sig module Foo : T.T end end
module FooBarInt : sig module Foo : sig type bar = int end end
type t = App(Bar)(Foo)(FooBarInt).Foo.bar
(* Note: I think correct result is:
type t = resolved[(global(Bar).T subst-> global(App)(resolved[global(Bar)])(resolved[global(Foo)])(resolved[global(FooBarInt)]).Foo).bar]
*)

BEFORE
======
module type (root Root).Type = sig
  module type (root Root).Type.T
  end
module (root Root).App : ((param (root Root).App T) : resolved[global((root Root).Type)]) -> ((param (root Root).App.result F) : ((param (param (root Root).App.result F) _) : resolved[global((root Root).Type)]) -> resolved[global((root Root).Type)]) -> ((param (root Root).App.result.result M) : resolved[global((param (root Root).App.result F))](resolved[global((param (root Root).App T))]).T) -> resolved[global((param (root Root).App.result F))](resolved[global((param (root Root).App T))]).T
module (root Root).Bar : sig
  module type (root Root).Bar.T = sig
    type (root Root).Bar.T.bar
    end
  end
module (root Root).Foo : ((param (root Root).Foo T) : resolved[global((root Root).Type)]) -> sig
  module type (root Root).Foo.result.T = sig
    module (root Root).Foo.result.T.Foo : resolved[global((param (root Root).Foo T))].T
    end
  end
module (root Root).FooBarInt : sig
  module (root Root).FooBarInt.Foo : sig
    type (root Root).FooBarInt.Foo.bar = resolved[global(int)]
    end
  end
type (root Root).t = resolved[global((root Root).App)](resolved[global((root Root).Bar)])(resolved[global((root Root).Foo)])(resolved[global((root Root).FooBarInt)]).Foo.bar

AFTER 
===== 
module type (root Root).Type = sig
  module type (root Root).Type.T
  end
module (root Root).App : ((param (root Root).App T) : resolved[global((root Root).Type)]) -> ((param (root Root).App.result F) : ((param (param (root Root).App.result F) _) : resolved[global((root Root).Type)]) -> resolved[global((root Root).Type)]) -> ((param (root Root).App.result.result M) : resolved[global((param (root Root).App.result F))(resolved[global((param (root Root).App T))]).T]) -> resolved[global((param (root Root).App.result F))(resolved[global((param (root Root).App T))]).T]
module (root Root).Bar : sig
  module type (root Root).Bar.T = sig
    type (root Root).Bar.T.bar
    end
  end
module (root Root).Foo : ((param (root Root).Foo T) : resolved[global((root Root).Type)]) -> sig
  module type (root Root).Foo.result.T = sig
    module (root Root).Foo.result.T.Foo : resolved[global((param (root Root).Foo T)).T]
    end
  end
module (root Root).FooBarInt : sig
  module (root Root).FooBarInt.Foo : sig
    type (root Root).FooBarInt.Foo.bar = resolved[global(int)]
    end
  end
type (root Root).t = resolved[(global((root Root).Bar).T subst-> global((root Root).App)(resolved[global((root Root).Bar)])(resolved[global((root Root).Foo)])(resolved[global((root Root).FooBarInt)]).Foo).bar]

