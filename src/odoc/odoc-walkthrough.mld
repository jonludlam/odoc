{0:top Resolving walkthough}

{1:resolving1 Resolving 1}

Let's start with a simple example. We'll resolve the path in the following
example:

{[
module M : sig module type S = sig type t end module T : S end

type v = M.T.t
]}

We're interested here in how [type v] gets resolved. 

When this is compiled, we get a cmti containing a typedtree, which can be seen by dumping the typedtree during
compilation via the [-dtypedtree] flag:

{v
[
  signature_item 
    Tsig_module "M/1002"
    module_type 
      Tmty_signature
      [
        signature_item 
          Tsig_modtype "S/1004"
            module_type 
              Tmty_signature
              [
                signature_item 
                  Tsig_type Rec
                  [
                    type_declaration t/1003 
                  ]
              ]
        signature_item 
          Tsig_module "T/1005"
          module_type 
            Tmty_ident "S/1004"
      ]
  signature_item 
    Tsig_type Rec
    [
      type_declaration v/1006 
        ptype_manifest =
          Some
            core_type 
              Ttyp_constr "M/1002.T.t"
              []
    ]
] 
v}

where I have omitted some irrelevant bits. So we can see from this that module M is [M/1002] and within that, [S] is [S/1003] and [T]
 is [T/1005]. Our type [v]
that we're interested in has a manifest of core_type [Ttyp_constr "M/1002.T.t"] - so we can see that only the outer
[M] has been exactly specified.

Odoc reads that in the {!module:Odoc__loader__Cmti} module {{:https://github.com/ocaml/odoc/blob/e714a19c715a31a97bcf4fca5339bc1f69d1d392/src/loader/cmti.ml#L74-L77}here},
creating a value:

{[
let walkthrough = 
  let open Odoc__model in
  let open Lang in
  let root = {Root.package = "walkthrough";
              file =
                Root.Odoc_file.Compilation_unit
                  {Root.Odoc_file.name = "Walkthrough__Test1";
                   hidden = true};
              digest = "abcde"}
  in
  let id = `Root (root, "Walkthrough__Test1") in 
  Compilation_unit.{
    id = id;
    doc = [];
    digest = "abcde";
    imports = Compilation_unit.Import.[
        Unresolved ("CamlinternalFormatBasics", Some "34567");
        Unresolved ("Odoc__alias", Some "67890");
        Unresolved ("Stdlib", Some "23456");
        Unresolved ("Walkthrough", Some "87654")];
    source =
      Some Compilation_unit.Source.{
          file = "test/walkthrough/test1.mli";
          build_dir = "/Users/jon/devel/odoc/_build/default";
          digest = "12345"};
    interface = true;
    hidden = true;
    content =
      Compilation_unit.Module
        [Signature.Module
           (Signature.Ordinary,
            {Module.id = `Module (id, "M");
             doc = [];
             type_ =
               Module.ModuleType
                 (ModuleType.Signature
                    [Signature.ModuleType
                       {ModuleType.id = `ModuleType (`Module (id, "M"), "S");
                        doc = [];
                        expr =
                          Some
                            (ModuleType.Signature
                               [Signature.Type
                                  (Signature.Ordinary,
                                   {TypeDecl.id =
                                      `Type (`ModuleType (`Module (id, "M"), "S"),"t");
                                    doc = [];
                                    equation =
                                      {TypeDecl.Equation.params = [];
                                       private_ = false; manifest = None; constraints = [] };
                                    representation = None})]);
                        expansion = Some Module.AlreadyASig};
                     Signature.Module
                       (Signature.Ordinary,
                        {Module.id = `Module (`Module (id,"M"), "T");
                         doc = [];
                         type_ =
                           Module.ModuleType
                             (ModuleType.Path (`Resolved (`Identifier (`ModuleType (`Module (id, "M"), "S")))));
                         canonical = None; hidden = false; display_type = None;
                         expansion = None})]);
             canonical = None; hidden = false; display_type = None;
             expansion = Some Module.AlreadyASig});
         Signature.Type (Signature.Ordinary,
                         {TypeDecl.id = `Type (id,"v");
                          doc = [];
                          equation = TypeDecl.Equation.{
                              params = []; private_ = false;
                              manifest = Some TypeExpr.(
                                  Constr (`Dot (`Dot (`Resolved (`Identifier (`Module (id, "M"))), "T"), "t"), []));
                              constraints = [] };
                          representation = None})];
    expansion = None}
]}

Where once again I have tidied it up a bit. We want to focus on the [Signature.Type] part of this, and specifically 
within that the [Path] in the [Constr] constructor:

{[
    Constr (`Dot (`Dot (`Resolved (`Identifier (`Module (root_id, ModuleName.of_string "M"))), "T"),"t"),[]));
]}

We can see here that the path to [t] is only partially resolved - the loader has identified that the
fully specified [M/1002] is the [M/1002] earlier in the file, so it marks that part of the
path as resolved. Let's see how the full resolution is accomplished.

The resolution step is done as a tree transformation on the {!type:Odoc__model.Lang.Compilation_unit.t}.  There is nothing to resolve in the declaration of M, so that ends up being essentially an identity transformation. 
So the first interesting point we get to is when we're trying to resolve the type defintion which in the code is in resolve.ml in the function to {{:https://github.com/ocaml/odoc/blob/e714a19c715a31a97bcf4fca5339bc1f69d1d392/src/xref/resolve.ml#L409}resolve the type path}.

The code is as follows:

{[
and resolve_type_path ident tbl (p : Path.Type.t) =
  match p with
  | `Resolved r ->
    let r' = resolve_resolved_type_path ident tbl r in
    if r != r' then `Resolved r' else p
  | `Dot(p, name) -> begin
      match resolve_parent_module_path ident tbl p with
      | Unresolved p -> `Dot(p, name)
      | Resolved(p, parent) ->
    ...
]}

We've got a [`Dot] so we call into {!value:resolve_parent_module_path} to resolve the [T]:

{[
and resolve_parent_module_path ident tbl (p : Path.Module.t) : parent_module_path =
    match p with
...
    | `Resolved r -> Resolved(r, CTbl.resolved_module_path tbl r)
    | `Dot(pr, name) -> begin
        match resolve_parent_module_path ident tbl pr with
        | Unresolved pr -> Unresolved(`Dot(pr, name))
        | Resolved(pr, parent) ->
            let resolved pr (`Module md : Parent.module_) =
              let pr = `Module (pr, ModuleName.of_string name) in
              let pr = if Sig.get_hidden md then `Hidden pr else pr in
              let pr =
                match Sig.get_canonical md with
                | None -> pr
                | Some (p, _) ->
                  resolve_canonical_path_module ident tbl (`Canonical(pr, p))
              in
              (Resolved(pr, md) : parent_module_path)
            in
            let unresolved pr =
              (Unresolved(`Dot(`Resolved pr, name)) : parent_module_path)
            in
              find_with_path_substs
                (Sig.find_parent_module name)
                resolved unresolved ident tbl pr parent
        end
]}

Again, we've got a [`Dot] so that invokes the recursive call, and now [p] is equal to [`Resolved (`Identifier (`Module (root_id, ModuleName.of_string "M")))], so we've reached
[`Resolved] part of the path; and we now call into {!value:Odoc__xref__Component_table.resolved_module_path} to find the
[Sig.t] that represents the parent module. This {!type:Odoc__xref__Components.Sig.t} is a representation of the module with which 
we can look up the contents of the module which will help us resolve the [T] we're looking for right now.  The arguments
to [resolved_module_path] are [tbl] and [r]. [r] is [`Identifier...], and [tbl] is an instance of
{!type:Component_table.t} created as part of the resolver class:
{[
  val tbl = CTbl.create ?equal ?hash lookup_unit fetch_unit lookup_page fetch_page]
]}
This has a hashtbl of {!type:Odoc__model.Root.t} to {!Odoc__xref__Components.Sig.t} which at this point is empty.

The function we call directly is a small wrapper that creates a {!type:Odoc__xref__Component_table.local} that exists for the duration of this
call:
{[
let resolved_module_path tbl p =
  let local = create_local tbl None in
    resolved_module_path local p
]}
the [local] is created with [base = None] as the context is the top level of the compilation unit at this point.

We now jump to [resolved_module_path] defined earlier in the file:

{[
  and resolved_module_path local (p : Path.Resolved.Module.t) =
  match p with
  | `Identifier (id : Identifier.Module.t) ->
      if is_local local (id :> Identifier.t) then local_module_identifier local id
      else module_identifier local.t id
...
]}

[is_local] is false since [base] is [None] hence we jump to [module_identifier] with [id] now [`Module (root_id, ModuleName.of_string "M")]:

{[
and module_identifier tbl (i : Identifier.Module.t) =
  match i with
  | `Root(base, _) -> unit tbl base
  | `Module(id, name) ->
      let parent = signature_identifier tbl id in
        Sig.lookup_module (ModuleName.to_string name) parent
]}

which finds the signature for the parent (in this case, [root_id]):

{[
and signature_identifier tbl (i : Identifier.Signature.t) =
  match i with 
  | `Root(base, _) -> unit tbl base
...
]},

in turn calling [unit tbl base], which is a hashtbl lookup in our table which will fail since
it's empty, which then causes us to load the unit in:

{[
let rec unit tbl base =
    try
      tbl.tbl.find base
    with Not_found ->
      let open Compilation_unit in
      let unt = tbl.fetch_unit base in
      let id = (unt.id : Identifier.Module.t :> Identifier.Signature.t) in
      let local = create_local tbl (Some id) in
      let t =
        match unt.content with
        | Module items ->
            Sig.signature
              (fun items ->
                 Sig.add_documentation unt.doc
                   (signature_items local items))
              items
        | Pack items ->
            Sig.signature
              (fun items ->
                 Sig.add_documentation unt.doc
                   (packed_items local items))
              items
      in
      let t = Sig.set_hidden t unt.hidden in
        tbl.tbl.add base t;
        t
]}

so we fetch the unit, which returns a {!type:Odoc__model.Lang.Compilation_unit.t}. We then create a local table of
identifiers that are in scope only in this particular module and then call [Sig.signature], whose purpose is simply
to construct a [Lazy.t] to delay the actual processing of the contents of this file, but let's continue pretending the
evaluation is eager. We then call [signature_items] with the contents of this compilation unit (which is in this case
the entire module we're working on).

[signature_items] iterates through the items in the [Compilation_unit.t]. In this instance, the first thing it finds
is the module [M], which as a reminder is this value:

{[
  Signature.Module
    (Signature.Ordinary,
    {Module.id = `Module (id, "M");
      doc = [];
      type_ =
        Module.ModuleType
          (ModuleType.Signature
            [Signature.ModuleType
                {ModuleType.id = `ModuleType (`Module (id, "M"), "S");
                doc = [];
                expr =
                  Some
                    (ModuleType.Signature
                        [Signature.Type
                          (Signature.Ordinary,
                            {TypeDecl.id =
                              `Type (`ModuleType (`Module (id, "M"), "S"),"t");
                            doc = [];
                            equation =
                              {TypeDecl.Equation.params = [];
                                private_ = false; manifest = None; constraints = [] };
                            representation = None})]);
                expansion = Some Module.AlreadyASig};
              Signature.Module
                (Signature.Ordinary,
                {Module.id = `Module (`Module (id,"M"), "T");
                  doc = [];
                  type_ =
                    Module.ModuleType
                      (ModuleType.Path (`Resolved (`Identifier (`ModuleType (`Module (id, "M"), "S")))));
                  canonical = None; hidden = false; display_type = None;
                  expansion = None})]);
      canonical = None; hidden = false; display_type = None;
      expansion = Some Module.AlreadyASig});
]}

so we hit 

{[
and signature_items local =
  let open Sig in
  let open Signature in function
    | Module (_, md) :: rest ->
        let open Module in
        let name = Identifier.name md.id in
        let decl = module_decl local md.type_ in
        let decl = set_canonical decl md.canonical in
        let decl = set_hidden decl md.hidden in
        add_local_module_identifier local md.id decl;
        let sg = signature_items local rest in
        let sg = add_documentation md.doc sg in
          add_module name decl sg
]}

We get the name, then call [module_decl] with the type of the module. In this case, the type is a straightforward [ModuleType] (as opposed to being an [Alias]), 
where the contents is a simple [Signature] (as opposed to being a [Path] to a module type declaration, a [Functor], [With]
which is a module type with some substitutions or a [TypeOf] which is a the type of another module declaration). The code is:

{[
and module_decl local decl =
  let open Sig in
  let open Module in
    match decl with
    | Alias p -> alias (module_path local) p
    | ModuleType expr -> module_type_expr local expr

and module_type_expr local expr =
  let open Sig in
  let open ModuleType in
  let open FunctorArgument in
    match expr with
    | Path p -> path (module_type_path local) p
    | Signature sg -> signature (signature_items local) sg
...
]}

We therefore end up going through [module_decl] and [module_type_expr] back to [signature_items], this time iterating
through the contents of our module [M]. The first element is our [ModuleType] [S], so we hit a different part of [signature_items]:

{[
  | ModuleType mty :: rest ->
    let open ModuleType in
    let name = Identifier.name mty.id in
    let expr =
      match mty.expr with
      | None -> abstract
      | Some expr -> module_type_expr local expr
    in
    add_local_module_type_identifier local mty.id expr;
    let sg = signature_items local rest in
    let sg = add_documentation mty.doc sg in
      add_module_type name expr sg
]}

This module type is not abstract - [expr] is not [None], so we once again call [module_type_expr]. Once again, it's a [Signature]
so we're in [signature_items] again (note, still with the same value [local]), but now we've got a [Type], so we get to:

{[
    | Type (_, decl) :: rest ->
        let open TypeDecl in
        let sg = signature_items local rest in
        let sg = add_documentation decl.doc sg in
        let name = Identifier.name decl.id in
        let decl = datatype decl in
          add_datatype name decl sg
]}

We recursively handle the rest of the items first, but in this the type definition is the only item - this results in
giving us an empty [Sig.signature]. We add the documentation associated with this type and then call [datatype] which returns a {!type:Odoc__xref__Components.Datatype.t}.
In this case the type is abstract, so we simply return [Datatype.abstract]:

{[
let datatype decl =
  let open TypeDecl in
  let open Representation in
  match decl.representation with
  | None -> Datatype.abstract
...
]}

so we then pass that to [add_datatype] in [Components]:

{[
  let add_datatype name decl sg =
    let types = SMap.add name `Type sg.types in
    let parents = LMap.add name (`Datatype decl) sg.parents in
    let elements =
      let add_element name (elem : Element.datatype) acc =
        let (`Constructor _ | `Field _ | `Label _ as elem) = elem in
          LMap.add name elem acc
      in
        LMap.fold add_element (Datatype.elements decl) sg.elements
    in
    let elements = LMap.add name `Type elements in
      {sg with types; parents; elements}
]}

Let's look at the type [Sig.signature]:

{[
  ...
  and signature =
    { modules: t SMap.t;
      module_types: t SMap.t;
      class_signatures: ClassSig.t SMap.t;
      types: Element.signature_type SMap.t;
      parents: Parent.any LMap.t;
      elements: Element.signature LMap.t;
      section_titles: Model.Comment.link_content SMap.t; }

]}

We have ['a SMap]s and ['a LMap]s, which are respectively string to single item ['a] maps, and string to ['a list] maps.
We add an entry saying "M.S.t is a type", and store the [decl] in the [parents] field (as type can be parents, for example
to constructors). Note that [parents] is a list because a single text identifier might correspond to both a module and a 
module type. We then update the [elements] to add all the constructors or record fields of [t], which in our case is none since [t] is abstract,
as well as [t] itself.

Unwinding the stack, we've now got the complete definition of [S] as a [Sig.signature], which we wrap into a [Sig.t],
which we're assigning as [expr] back here:

{[
  | ModuleType mty :: rest ->
    let open ModuleType in
    let name = Identifier.name mty.id in
    let expr =
      match mty.expr with
      | None -> abstract
      | Some expr -> module_type_expr local expr
    in
    add_local_module_type_identifier local mty.id expr;
    let sg = signature_items local rest in
    let sg = add_documentation mty.doc sg in
      add_module_type name expr sg
]}

we now call [add_local_module_type_identifier] which simply adds an entry to the local map mapping [M.S] to the [Sig.t]
we've just created. At this point we now do the recursive call to [signature_items] to handle the rest of the signature
items, which in this case is now the module declaration, which in the original source was:

{[
  module T : S
]}

Odoc's value representing that is this:
{[
  Signature.Module
    (Signature.Ordinary,
    {Module.id = `Module (`Module (id,"M"), "T");
      doc = [];
      type_ =
        Module.ModuleType
          (ModuleType.Path (`Resolved (`Identifier (`ModuleType (`Module (id, "M"), "S")))));
      canonical = None; hidden = false; display_type = None;
      expansion = None})
]}

It's worth noting at this point that the paths are fully qualified - the identifier for [T] is [M.T] and
for [S] it's [M.S].

So, we're back in the [signature_items] code, this time handling a [Module]:

{[
  | Module (_, md) :: rest ->
    let open Module in
    let name = Identifier.name md.id in
    let decl = module_decl local md.type_ in
    let decl = set_canonical decl md.canonical in
    let decl = set_hidden decl md.hidden in
    add_local_module_identifier local md.id decl;
    let sg = signature_items local rest in
    let sg = add_documentation md.doc sg in
      add_module name decl sg
]}

our [type] this time is a path, so when we call [module_decl] and in turn [module_type_expr] as before, we end up at:

{[
    | Path p -> path (module_type_path local) p
]}

so we call into [module_type_path]:

{[
  and module_type_path local = function
  | `Resolved r -> resolved_module_type_path local r
  | `Dot(p, name) ->
      let parent = module_path local p in
        Sig.lookup_module_type name parent
]}

the path is already resolved, so we call into [resolved_module_type_path]:

{[
and resolved_module_type_path local (p : Path.Resolved.ModuleType.t) =
  match p with
  | `Identifier (id : Identifier.ModuleType.t) ->
      if is_local local (id :> Identifier.t) then local_module_type_identifier local id
      else module_type_identifier local.t id
  | `ModuleType(p, name) ->
      let parent = resolved_module_path local p in
        Sig.lookup_module_type (ModuleTypeName.to_string name) parent
]}

The call to [is_local] checks to see if this identifier is rooted in the current module, which it is, and then
simply calls [local_module_type_identifier] which looks up the value of [M.S] from our local hashtbl, returning
the [Sig.t] we stashed in there earlier. We're then back to 

{[
    | Path p -> path (module_type_path local) p
]}

so we call {!val:Odoc__xref__Components.Sig.path} which constructs a simple [Sig.t] that's an [Expr] - which
in this case is a combination of the fact that it was a path and the signature that the path corresponds to - 
in this case [M.S]. So when we lookup [T] in [M] we'll indirect through this [Path] and return the module_type_expression
that is [M.S].

So we then we're back in [signature_items] again:

{[
    | Module (_, md) :: rest ->
        let open Module in
        let name = Identifier.name md.id in
        Printf.fprintf stderr "Found a module: %s\n" name;
        let decl = module_decl local md.type_ in
        let decl = set_canonical decl md.canonical in
        let decl = set_hidden decl md.hidden in
        add_local_module_identifier local md.id decl;
        let sg = signature_items local rest in
        let sg = add_documentation md.doc sg in
          add_module name decl sg
]}

we add the module [T] to [local], and then do the recursive call to [signature_items]. This time there's no more,
[rest] is [[]], so get get back an empty [Sig.signature], into which we add the documentation and then the module
itself:

{[
  let add_module name md sg =
    let modules = SMap.add name md sg.modules in
    let parents = LMap.add name (`Module md) sg.parents in
    let elements =
      let md = `Module Element.{ canonical=md.canonical; hidden=md.hidden } in
      LMap.add name md sg.elements
    in
      {sg with modules; parents; elements}
]}

so we're adding our module to [sg.modules], [sg.parents] and [sg.elements]. Note that we're adding it with a
relative identifier - "T" rather than a fully qualified "M.T". Note also that we don't add the contents
of our module as elements, unlike for type declarations.

We're not quite finished yet. We've got a [Sig.t] that represents [M], but not the entire compilation unit, so we
are back here:

{[
  | Module (_, md) :: rest ->
    let open Module in
    let name = Identifier.name md.id in
    let decl = module_decl local md.type_ in
    let decl = set_canonical decl md.canonical in
    let decl = set_hidden decl md.hidden in
    add_local_module_identifier local md.id decl;
    let sg = signature_items local rest in
    let sg = add_documentation md.doc sg in
      add_module name decl sg
]}

We add [M] to the local identifiers hashtbl and recurse down [rest], which contains the single type declaration [t]:

{[
          Signature.Type (Signature.Ordinary,
                         {TypeDecl.id = `Type (id,"v");
                          doc = [];
                          equation = TypeDecl.Equation.{
                              params = []; private_ = false;
                              manifest = Some TypeExpr.(
                                  Constr (`Dot (`Dot (`Resolved (`Identifier (`Module (id, "M"))), "T"), "t"), []));
                              constraints = [] };
                          representation = None})
]}

we're here in [signature_items]:

{[
      | Type (_, decl) :: rest ->
        let open TypeDecl in
        let sg = signature_items local rest in
        let sg = add_documentation decl.doc sg in
        let name = Identifier.name decl.id in
        let decl = datatype decl in
          add_datatype name decl sg
]}

There is no [rest], so the recursive call gives us an empty [Sig.signature]. We add the documentation and then call
[datatype decl]. This simply looks at the representation, sees it's [None] and returns [Datatype.abstract]. We then
pop that into our empty [sg], unwind back, add [M], and we've finally got a [Sig.t] that represents the compilation unit.
We add that into our hashtbl so we never need do that again, and then we're back looking up the [Sig.t] for our identifier
[`Module (root_id, ModuleName.of_string "M")]

{[
and module_identifier tbl (i : Identifier.Module.t) =
  match i with
  | `Root(base, _) -> unit tbl base
  | `Module(id, name) ->
      let parent = signature_identifier tbl id in
        Sig.lookup_module (ModuleName.to_string name) parent
]}

so we call [Sig.lookup_module "M" sig], which amounts to a straightforward SMap.find:

{[
  let rec lookup_module name t =
    match t.body with
    | Expr expr -> lookup_module name (Lazy.force expr.expansion)
    | Sig sg -> begin
        try
          SMap.find name (Lazy.force sg).modules
        with Not_found -> unresolved
      end
    | Functor fn -> lookup_module name fn.res
    | Generative t -> lookup_module name t
    | Abstract -> unresolved
    | Unresolved -> unresolved
]}

Now we unwind back into the [resolve.ml] module:

{[
  | `Dot(pr, name) -> begin
    match resolve_parent_module_path ident tbl pr with
    | Unresolved pr -> Unresolved(`Dot(pr, name))
    | Resolved(pr, parent) ->
        let resolved pr (`Module md : Components.Parent.module_) =
          let pr = `Module (pr, ModuleName.of_string name) in
          let pr = if Components.Sig.get_hidden md then `Hidden pr else pr in
          let pr =
            match Components.Sig.get_canonical md with
            | None -> pr
            | Some (p, _) ->
              resolve_canonical_path_module ident tbl (`Canonical(pr, p))
          in
          (Resolved(pr, md) : parent_module_path)
        in
        let unresolved pr =
          (Unresolved(`Dot(`Resolved pr, name)) : parent_module_path)
        in
          find_with_path_substs
            (Components.Sig.find_parent_module name)
            resolved unresolved ident tbl pr parent
  end 
]}

we've got back a [Resolved(pr,parent)] where [pr] is the path and [parent] is the [Sig.t] representing [M]. We construct two
functions [resolved] and [unresolved], we get the  and call [find_with_path_substs]. The 'substs' referred to here are when 
overriding types or modules, which doesn't apply here and we simply end up calling the function [resolved] on the result of
[find_parent_module name parent] which is looking for "T" in [parent]. This returns the [Sig.t] representing [T] wrapped in
a polymorphic variant [`Module of Sig.t]. Note that we saw above that we stored [T] in [M]'s [Sig.t] as a [Path] constructor
that contains the module type corresponding to [M.S]. This is then passed to the function [resolved] which constructs a resolved path
[`Module (`Identifier (`Module (id, "M")), "T")]. We then get back to [resolve_type_path]:

{[
  | `Dot(p, name) -> begin
    match resolve_parent_module_path ident tbl p with
    | Unresolved p -> `Dot(p, name)
    | Resolved(p, parent) ->
        let resolved p : Components.Element.signature_type -> _ = function
          | `Type -> `Resolved (`Type(p, TypeName.of_string name))
          | `Class -> `Resolved (`Class(p, ClassName.of_string name))
          | `ClassType -> `Resolved (`ClassType(p, ClassTypeName.of_string name))
        in
        let unresolved p =
          `Dot(`Resolved p, name)
        in
          find_with_path_substs
            (Components.Sig.find_type_element name)
            resolved unresolved ident tbl p parent
]}

This is clearly very similar to the code in [resolve_parent_module_path]. This time we'll call [Components.Sig.find_type_element "t" parent]
where [parent] is the [Sig.t] representing [M.T] - which is [M.S]. [t] was stored in there as an element, and hence we
apply [resolved] to what we stored as an element, which was [`Type], so we return with [`Resolved (`Type (`Module (`Identifier (`Module (id, "M")), "T"),"t"))].
