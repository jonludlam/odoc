{0 Features}

Odoc works by taking module interfaces, processing them to make them more
useful, and turning them into documentation.
The processing that odoc does is largely {i hiding}, {i expansion} and {i resolution},
and this document explains the features of these processes in detail.

{1 Hiding}

Some items are not intended to be used directly but are present as
implementation detail, for example for testing, or for implementing dune's
namespacing, or other reasons. 

There are two mechanisms for explicitly hiding elements from the final
output. The first is to use {{:https://ocaml.org/manual/ocamldoc.html#ss:ocamldoc-stop}documentation stop comments},
which can be used to hide any items at all from the output. The second
mechanism is only used for modules, and is a naming convention. If any
module has a double underscore in its name, it is considered to be
hidden.

{1 Expansion}

There are many instances of items in signatures where what's written is
the best thing in terms of semantics, but not necessarily useful in terms
of documentation. For example:

{[
module StringSet : Stdlib.Set.S with type t = string
]}

Odoc will {e expand} these items, augmenting the declaration with the
signature along with all the documentation comments that can be found,
so in this case those from [Stdlib.Set.S]. While the compiler also does
a very similar procedure and determines the signature of the module,
odoc tries quite hard to preserve as much as possible from the context
of the original items. 

The declaration can be seen rendered {{!Odoc_examples.Expansion.Simple}here}, 
and the full expansion can be found by clicking on the name of the module
([StringSet] in this case), or the direct link is {{!Odoc_examples.Expansion.Simple.StringSet}here}.

These expansions have to be done carefully. A number of cases follow
in which odoc has to treat specially.

{2 Aliases}

In general odoc does not expand module aliases, unless they are an
alias to a hidden module. If this is the case the right-hand side of
the declaration is dropped and replaced with [sig ... end] and
the expansion is created.

For example, given the following source,

{[

module Hidden__module : sig
  type t
  val f : t -> t
end

module Alias = Hidden__module

]}

then the [Hidden__module] module will not be present in the output, and
the [Alias] module will be rendered as if it were a simple
signature. This can be seen in the example rendering {{!Odoc_examples.Expansion.Aliases}here}.

{2 Deep constraints}

The module type system allows for constraints on abstract types 
(as seen above in the [StringSet] declaration). These constraints
may be 'deep' in the sense that they operate on a nested module
rather than the outer one. For example,

{[
module type SIG = sig
  type t
end

module type MODTYPE = sig
  module X : SIG
  module Y : SIG
end

type foo

module M : MODTYPE with type X.t = foo
]}

Here we've got a module type [SIG] that contains an opaque type [t].
Then a module type [MODTYPE] that contains two modules, [X] and [Y],
that have signature [SIG]. Lastly we declare a module [M] that
has signature [MODTYPE] with an additional type equality [X.t = foo].
When the compiler evaluates
the signature of module [M] here, the definition of [X]
within it is simply replaced with a signature:

{[
module M : sig
  module X : sig type t = foo end
  module Y : SIG
end
]}

and we lose both the fact that it came from [MODTYPE] and also
that within it [X] originally had signature [SIG]. Odoc tries
to be more careful and instead with keep both the [MODTYPE] on [M] with the 
type equality [X.t = foo], 
and the [SIG] on [X] with the type equality [t = foo]. The expansion of
of module M in this example can be seen {{!Odoc_examples.Expansion.DeepConstraint.M}here}.

{2 Type substitution}

In a similar way to adding type equalities, we can do type substitution where
a type from a signature is removed entirely from the signature and a replacement
substituted in its place. For example:



